// dbManager.js - Vers√£o CORRIGIDA sem reset autom√°tico de dados
class DBManager {
    constructor() {
        this.dbName = 'PMG_AgendaClientes_DB_PERSISTENT';
        this.dbVersion = 1; // Vers√£o fixa para evitar conflitos
        this.db = null;
        this.isInitialized = false;
        
        this.stores = ['clients', 'ativos', 'novos', 'schedules', 'observations', 'cache'];
        this.retryConfig = { maxRetries: 2, baseDelay: 1000 };
        
        console.log('‚úÖ DBManager inicializado - modo persistente');
    }

    async init() {
        if (this.isInitialized) {
            console.log('‚úÖ DBManager j√° inicializado');
            return true;
        }

        try {
            console.log('üîß Inicializando DBManager persistente...');
            
            // N√ÉO fazer limpeza autom√°tica - apenas abrir o banco
            this.db = await this.openDatabase();
            this.setupHandlers();
            this.isInitialized = true;
            
            console.log('‚úÖ DBManager inicializado (dados preservados)');
            return true;
            
        } catch (error) {
            console.error('‚ùå Erro DBManager:', error);
            
            // S√≥ resetar se realmente for necess√°rio
            if (error.name === 'VersionError') {
                console.log('üîÑ Tentando resolver conflito de vers√£o...');
                await this.handleVersionConflict();
                return await this.init();
            }
            
            throw error;
        }
    }

    async handleVersionConflict() {
        try {
            console.log('üîß Resolvendo conflito de vers√£o...');
            
            if (this.db) {
                this.db.close();
                this.db = null;
            }
            
            // Apenas incrementar vers√£o, N√ÉO deletar dados
            this.dbVersion++;
            this.isInitialized = false;
            
            console.log(`üîÑ Nova vers√£o: ${this.dbVersion}`);
            
        } catch (error) {
            console.error('‚ùå Erro ao resolver conflito:', error);
        }
    }

    async openDatabase() {
        return new Promise((resolve, reject) => {
            console.log(`üì° Abrindo ${this.dbName} v${this.dbVersion}`);
            
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.error('‚ùå Erro IndexedDB:', request.error);
                reject(request.error);
            };
            
            request.onblocked = () => {
                console.warn('üöß Opera√ß√£o bloqueada');
                setTimeout(() => reject(new Error('Bloqueado')), 3000);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                const oldVersion = event.oldVersion;
                const newVersion = event.newVersion;
                
                console.log(`üîÑ Upgrade ${oldVersion} ‚Üí ${newVersion}`);
                
                // Criar stores que n√£o existem (preservar dados existentes)
                this.stores.forEach(storeName => {
                    if (!db.objectStoreNames.contains(storeName)) {
                        const store = db.createObjectStore(storeName);
                        console.log(`üìÅ Store ${storeName} criada`);
                        
                        // Adicionar √≠ndices se necess√°rio
                        if (['clients', 'ativos', 'novos'].includes(storeName)) {
                            try {
                                store.createIndex('nome', 'Nome Fantasia', { unique: false });
                                store.createIndex('status', 'Status', { unique: false });
                            } catch (indexError) {
                                console.warn(`‚ö†Ô∏è √çndice em ${storeName}:`, indexError);
                            }
                        }
                    }
                });
            };
            
            request.onsuccess = () => {
                const db = request.result;
                console.log(`‚úÖ Database aberto v${db.version}`);
                resolve(db);
            };
        });
    }

    setupHandlers() {
        if (!this.db) return;
        
        this.db.onversionchange = () => {
            console.log('üîÑ Vers√£o alterada por outra aba');
            this.db.close();
            this.isInitialized = false;
            
            // Recarregar apenas se necess√°rio
            setTimeout(() => {
                window.location.reload();
            }, 2000);
        };
        
        this.db.onerror = (event) => {
            console.error('‚ùå Erro DB:', event);
        };
    }

    async saveData(storeName, data) {
        if (!this.isInitialized) await this.init();
        
        try {
            console.log(`üíæ Salvando em ${storeName}...`);
            
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            // Limpar store atual
            await new Promise((resolve, reject) => {
                const clearRequest = store.clear();
                clearRequest.onsuccess = () => resolve();
                clearRequest.onerror = () => reject(clearRequest.error);
            });
            
            // Salvar novos dados
            if (Array.isArray(data)) {
                for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    const key = item.id || item['ID Cliente'] || `item_${i}_${Date.now()}`;
                    
                    await new Promise((resolve, reject) => {
                        const putRequest = store.put(item, key);
                        putRequest.onsuccess = () => resolve();
                        putRequest.onerror = () => reject(putRequest.error);
                    });
                }
                console.log(`‚úÖ ${data.length} itens salvos em ${storeName}`);
            } else {
                await new Promise((resolve, reject) => {
                    const putRequest = store.put(data, 'data');
                    putRequest.onsuccess = () => resolve();
                    putRequest.onerror = () => reject(putRequest.error);
                });
                console.log(`‚úÖ Objeto salvo em ${storeName}`);
            }
            
            return true;
            
        } catch (error) {
            console.error(`‚ùå Erro ao salvar ${storeName}:`, error);
            return false;
        }
    }

    async loadData(storeName) {
        if (!this.isInitialized) await this.init();
        
        try {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            
            // Tentar carregar todos os itens
            const allRequest = store.getAll();
            const result = await new Promise((resolve, reject) => {
                allRequest.onsuccess = () => resolve(allRequest.result);
                allRequest.onerror = () => reject(allRequest.error);
            });
            
            if (result && result.length > 0) {
                console.log(`üìñ ${result.length} itens carregados de ${storeName}`);
                return result;
            }
            
            // Tentar item √∫nico
            const singleRequest = store.get('data');
            const singleResult = await new Promise((resolve, reject) => {
                singleRequest.onsuccess = () => resolve(singleRequest.result);
                singleRequest.onerror = () => reject(singleRequest.error);
            });
            
            if (singleResult !== undefined) {
                console.log(`üìñ Item √∫nico carregado de ${storeName}`);
                return singleResult;
            }
            
            // Retornar valor padr√£o
            const defaultValue = ['schedules', 'observations', 'cache'].includes(storeName) ? {} : [];
            console.log(`üìñ Valor padr√£o para ${storeName}`);
            return defaultValue;
            
        } catch (error) {
            console.error(`‚ùå Erro ao carregar ${storeName}:`, error);
            return ['schedules', 'observations', 'cache'].includes(storeName) ? {} : [];
        }
    }

    async clearData(storeName) {
        if (!this.isInitialized) await this.init();
        
        try {
            console.log(`üßπ Limpando ${storeName}...`);
            
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            await new Promise((resolve, reject) => {
                const clearRequest = store.clear();
                clearRequest.onsuccess = () => resolve();
                clearRequest.onerror = () => reject(clearRequest.error);
            });
            
            console.log(`‚úÖ ${storeName} limpo`);
            return true;
            
        } catch (error) {
            console.error(`‚ùå Erro ao limpar ${storeName}:`, error);
            return false;
        }
    }

    // M√©todos de conveni√™ncia para observa√ß√µes
    async saveObservation(clientId, observation) {
        try {
            const observations = await this.loadData('observations');
            observations[clientId] = {
                text: observation,
                updatedAt: new Date().toISOString()
            };
            return await this.saveData('observations', observations);
        } catch (error) {
            console.error('‚ùå Erro ao salvar observa√ß√£o:', error);
            return false;
        }
    }

    async loadObservation(clientId) {
        try {
            const observations = await this.loadData('observations');
            return observations[clientId]?.text || '';
        } catch (error) {
            console.error('‚ùå Erro ao carregar observa√ß√£o:', error);
            return '';
        }
    }

    // M√©todo para for√ßar reset (apenas quando explicitamente solicitado)
    async forceReset() {
        try {
            console.log('üö® RESET FOR√áADO do banco de dados...');
            
            if (this.db) {
                this.db.close();
                this.db = null;
            }
            
            await this.deleteDatabase();
            this.isInitialized = false;
            
            console.log('‚úÖ Reset for√ßado conclu√≠do');
            
        } catch (error) {
            console.error('‚ùå Erro no reset for√ßado:', error);
        }
    }

    async deleteDatabase() {
        return new Promise((resolve) => {
            console.log('üóëÔ∏è Deletando database...');
            const request = indexedDB.deleteDatabase(this.dbName);
            
            request.onsuccess = () => {
                console.log('‚úÖ Database deletado');
                resolve(true);
            };
            
            request.onerror = () => {
                console.warn('‚ö†Ô∏è Erro ao deletar');
                resolve(false);
            };
            
            request.onblocked = () => {
                console.warn('üöß Delete bloqueado');
                setTimeout(() => resolve(false), 2000);
            };
        });
    }

    destroy() {
        if (this.db) {
            this.db.close();
            this.db = null;
        }
        this.isInitialized = false;
        console.log('üîß DBManager destru√≠do');
    }
}

window.dbManager = new DBManager();
console.log('‚úÖ dbManager.js PERSISTENTE carregado');
